#1. Написать функцию, вычисляющую НОД двух чисел (или многочленов)

function gcd_(a::T,b::T)::T where T
    while b > 0
        a,b = b,mod(a,b)
    end

    return a
end

#=
2. Написать функцию, реализующую расширенный алгоритм Евклида, вычисляющий не только НОД, но и коэффициенты его линейного представления.

**Утверждение.** Пусть d=НОД(a, b), тогда существуют такие целые коэффициенты u, v, что d=u*a+v*b

Мы спроектируем расширенный алгоритм Евклида с помощью инварианта цикла, и тем самым будет доказаго это утверждение.

Напомним, что инвариантом цикла (с передусловием) называется некотрое утверждение относительно переменных, изменяющихся в цикле, которое справедливо как перед началом выполнения цикла, так и после любого числа его повторений.

В данном случае в качестве инварианта цикла возьмём утверждение 
=#

function gcdx_(a::T,b::T)::Tuple{T,T,T} where T
#= хазиевские таблицы
	[	a	b	]
	[	u	v	]
	[	u_	v_	]
=#
	a,b = max(a,b),min(a,b)
	u,v = 1,0
	u_,v_ = 0,1

	while b > 0
		k = div(a,b);
		a,b = b,a - k * b
		u,v = v,u - k * v
		u_,v_ = v_,u_ - k * v_
	end

	s = sign(a)

	return (
		a * s ,
		u * s ,
		u_ * s
	)
end

#=
3. С использованием функции gcdx_ реаализовать функцию invmod_(a::T, M::T) where T, которая бы возвращала бы обратное значение инвертируемого элемента (a) кольца вычетов по модулю M, а для необращаемых элементов возвращала бы nothing.

(если положить M=b  и если d = ua+vb, то при условии, что d=1, a^-1 = u, в противном случае элемент a не обратим)
=#

function invmod_(a::T, M::T)#=::T=# where T
	info = gcdx(a,M)

	return info[1] > 1 ? nothing : mod( info[2] , M )
end

#=
4. С использованием функции gcdx_ реализовать функцию diaphant_solve(a::T,b::T,c::T) where T, которая бы возвращала решение дафаетового уравнения ax+by=c, если уравнение разрешимо, и значение nothing - в противном случае
   
(если d=ua+vb, и если получилость, что d=1, u, v - есть решение уравнения, в противном случае уранение не разрешимо)
=#

function diaphant_solve(a::T,b::T,c::T)#=::Tuple{T,T}=# where T <: Number
	info = gcdx(a,b)

	return info[1] > 1 ? nothing : ( info[2] * c , info[3] * c )
end